<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="Manager.ttinclude" #>
<#
    var manager = Manager.Create(Host, GenerationEnvironment); 

    List<ValueDescription> negativeValues = new List<ValueDescription>
    {
        new ValueDescription("NegativeWhole", -2d),
        new ValueDescription("NegativeFraction", -0.5d),
    };
	
    List<ValueDescription> positiveValues = new List<ValueDescription>
    {
        new ValueDescription("PositiveWhole", 2d),
        new ValueDescription("PositiveFraction", 0.5d),
    };
	
	List<OperatorDescription> leftRightOperators = new List<OperatorDescription>
	{
		new OperatorDescription("Addition", "+", (a,b)=>a+b),
		new OperatorDescription("Subtraction", "-", (a,b)=>a-b, true),
		new OperatorDescription("Multiplication", "*", (a,b)=>a*b),
		new OperatorDescription("Division", "/", (a,b)=>a/b),
		new OperatorDescription("Power", "^", (a,b)=>Math.Pow(a,b)),
	};
    
	var values = positiveValues.Union(negativeValues).ToList();
	foreach(var od in leftRightOperators)
	{
        manager.StartNewFile(od.OpName + "OperatorTests.generated.cs"); 
        StartClass(od.OpName + "OperatorTests");    
        WriteLeftRightOperatorTests(od.OpName, od.Op, values, od.Calculator);
        WriteMalformedLeftOfOperatorTests(od.OpName, od.Op, values, od.Calculator);
		if (od.MalformedRightNegativeOnly)
	        WriteMalformedRightOfOperatorTests(od.OpName, od.Op, negativeValues, od.Calculator);
		else
	        WriteMalformedRightOfOperatorTests(od.OpName, od.Op, values, od.Calculator);
			
        EndClass();
        manager.EndBlock(); 
	}
	
	manager.Process(true); 
#>
<#+
    public void WriteLeftRightOperatorTests(
        string opName, 
        string op,
        List<ValueDescription> values,
        Func<double, double, double> calculator)
    {
        foreach (var vd1 in values)
        {
            foreach (var vd2 in values)
            {
                double outputVal = calculator(vd1.Value, vd2.Value);
                var valueString = double.NaN.Equals(outputVal) ? "double.NaN" : outputVal.ToString("R") + "d";
#>
        [Test]
        public void <#= opName #>Operator_<#= vd1.Description #>AddedTo<#= vd2.Description #>_IsCorrect()
        {
            func.Function = "<#= vd1.Value #> <#= op #> <#= vd2.Value#>";
            Assert.AreEqual(<#= valueString #>, func.EvaluateNumeric());
        }
		
<#+
            }
        }
	}
	
    public void WriteMalformedRightOfOperatorTests(
        string opName, 
        string op,
        List<ValueDescription> values,
        Func<double, double, double> calculator)
    {
        foreach (var vd1 in values)
        {
#>
        [Test]
        [ExpectedException(typeof(ExpressionException), ExpectedMessage = "Operator error", MatchType = MessageMatch.Contains)]
        public void <#= opName #>Operator_MalformedExpression<#= vd1.Description #>RightOfOperator_ThrowsException()
        {
            func.Function = "<#= op #> <#= vd1.Value #>";
        }
		
<#+
        }
    }

    public void WriteMalformedLeftOfOperatorTests(
        string opName, 
        string op,
        List<ValueDescription> values,
        Func<double, double, double> calculator)
    {
        foreach (var vd1 in values)
        {
#>
        [Test]
        [ExpectedException(typeof(ExpressionException), ExpectedMessage = "Operator error", MatchType = MessageMatch.Contains)]
        public void <#= opName #>Operator_MalformedExpression<#= vd1.Description #>LeftOfOperator_ThrowsException()
        {
            func.Function = "<#= vd1.Value #> <#= op #>";
        }
		
<#+
        }
    }

    public void StartClass(string name)
    {
#>
// ReSharper disable InconsistentNaming
using NUnit.Framework;
using Vanderbilt.Biostatistics.Wfccm2;

namespace ExpressionEvaluatorTests
{
    [TestFixture]
    public class <#= name #>
    {
        Expression func;

        [SetUp]
        public void init()
        { this.func = new Expression(""); }

        [TearDown]
        public void clear()
        { func.Clear(); }
        
<#+
    }

    public void EndClass()
    {
#>
    }
}
<#+
    }

    public class ValueDescription
    {
        public ValueDescription(string description, double value)
        {
            Value = value;
            Description = description;
        }
        
        public double Value;
        public string Description;
    }

    public class OperatorDescription
    {
        public OperatorDescription(string opName, string op, Func<double, double, double> calculator, bool malformedRightNegativeOnly)
		{
            OpName = opName;
    		Op = op;
	    	Calculator = calculator;
			MalformedRightNegativeOnly = malformedRightNegativeOnly;
		}
		
        public OperatorDescription(string opName, string op, Func<double, double, double> calculator)
        {
            OpName = opName;
    		Op = op;
	    	Calculator = calculator;
        }
        
        public string OpName;
		public string Op;
		public Func<double, double, double> Calculator;
		
		public bool MalformedRightNegativeOnly = false;
	}
#>