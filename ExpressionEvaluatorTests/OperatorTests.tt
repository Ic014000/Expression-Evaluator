<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="Manager.ttinclude" #>
<#
    var manager = Manager.Create(Host, GenerationEnvironment); 

    List<ValueDescription> values = new List<ValueDescription>
    {
        new ValueDescription("PositiveWhole", 2D),
        new ValueDescription("PositiveFraction", 0.5D),
        new ValueDescription("NegativeWhole", -2D),
        new ValueDescription("NegativeFraction", -0.5D),
    };
	
	List<OperatorDescription> leftRightOperators = new List<OperatorDescription>
	{
		new OperatorDescription("Addition", "+", (a,b)=>a+b),
		new OperatorDescription("Subtraction", "-", (a,b)=>a-b),
		new OperatorDescription("Multiplication", "*", (a,b)=>a*b),
		new OperatorDescription("Division", "/", (a,b)=>a/b),
		new OperatorDescription("Power", "^", (a,b)=>Math.Pow(a,b)),
	};
    
	foreach(var od in leftRightOperators)
	{
        manager.StartNewFile(od.OpName + "OperatorTests.generated.cs"); 
        StartClass(od.OpName + "OperatorTests");    
        WriteLeftRightOperatorTests(od.OpName, od.Op, values, od.Calculator);
        EndClass();
        manager.EndBlock(); 
	}

	manager.Process(true); 
#>
<#+
    public void WriteLeftRightOperatorTests(
        string opName, 
        string op,
        List<ValueDescription> values,
        Func<double, double, double> calculator)
    {
        foreach (var vd1 in values)
        {
            foreach (var vd2 in values)
            {
                double outputVal = calculator(vd1.Value, vd2.Value);
                var valueString = double.NaN.Equals(outputVal) ? "double.NaN" : outputVal.ToString();
#>
        [Test]
        public void <#= opName #>Operator_<#= vd1.Description #>AddedTo<#= vd2.Description #>_IsCorrect()
        {
            func.Function = "<#= vd1.Value #> <#= op #> <#= vd2.Value#>";
            Assert.AreEqual(<#= valueString #>, func.EvaluateNumeric());
        }
		
<#+
            }
        }
    }

    public void StartClass(string name)
    {
#>
// ReSharper disable InconsistentNaming
using NUnit.Framework;
using Vanderbilt.Biostatistics.Wfccm2;

namespace ExpressionEvaluatorTests
{
    [TestFixture]
    public class <#= name #>
    {
        Expression func;

        [SetUp]
        public void init()
        { this.func = new Expression(""); }

        [TearDown]
        public void clear()
        { func.Clear(); }
        
<#+
    }

    public void EndClass()
    {
#>
    }
}
<#+
    }

    public class ValueDescription
    {
        public ValueDescription(string description, double value)
        {
            Value = value;
            Description = description;
        }
        
        public double Value;
        public string Description;
    }

    public class OperatorDescription
    {
        public OperatorDescription(string opName, string op, Func<double, double, double> calculator)
        {
            OpName = opName;
    		Op = op;
	    	Calculator = calculator;
        }
        
        public string OpName;
		public string Op;
		public Func<double, double, double> Calculator;
	}
#>