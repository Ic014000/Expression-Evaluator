<#@ template language="C#" hostspecific="True" debug="True" #>
<#@ assembly name="System.Core.dll" #>
<#@ output extension="cs" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="T4Toolbox.tt" #>
<#@ include file="TestsTemplate.tt" #>
<#@ include file="FunctionTestsTemplate.tt" #>
<#@ include file="OperatorTestsTemplate.tt" #>
<#@ include file="CaseTestsTemplate.tt" #>
<#@ include file="PrecedenceTestsTemplate.tt" #>
<#

    List<ValueDescription> negativeValues = new List<ValueDescription>
    {
        new ValueDescription("NegativeWhole", -2d),
        new ValueDescription("NegativeFraction", -0.5d),
    };
    
    List<ValueDescription> positiveValues = new List<ValueDescription>
    {
        new ValueDescription("PositiveWhole", 2d),
        new ValueDescription("PositiveFraction", 0.5d),
    };
    
    var doubleDoubleFunctions = new List<ProcedureDescription<Func<double, string>>>
    {
        new ProcedureDescription<Func<double, string>>("Ln", "ln", x=> GetString(Math.Log(x))),
        new ProcedureDescription<Func<double, string>>("Neg", "neg", x => GetString(-x)),
        new ProcedureDescription<Func<double, string>>("Abs", "abs", x => GetString(Math.Abs(x))),
        new ProcedureDescription<Func<double, string>>("Sign", "sign", x => GetString(x < 0 ? -1 : 1)),
        new ProcedureDescription<Func<double, string>>("Days", "days", x => GetString(new TimeSpan((long)(x * TimeSpan.TicksPerDay))), "<TimeSpan>"),
        new ProcedureDescription<Func<double, string>>("Hours", "hours", x => GetString(new TimeSpan((long)(x * TimeSpan.TicksPerHour))), "<TimeSpan>"),
        new ProcedureDescription<Func<double, string>>("Minutes", "minutes", x => GetString(new TimeSpan((long)(x * TimeSpan.TicksPerMinute))), "<TimeSpan>"),
        new ProcedureDescription<Func<double, string>>("Seconds", "seconds", x => GetString(new TimeSpan((long)(x * TimeSpan.TicksPerSecond))), "<TimeSpan>"),
    };

    var leftRightOperators = new List<ProcedureDescription<Func<double, double, string>>>
    {
        new ProcedureDescription<Func<double, double, string>>("Addition", "+", (a,b) => GetString(a+b)),
        new ProcedureDescription<Func<double, double, string>>("Subtraction", "-", (a,b) => GetString(a-b), true),
        new ProcedureDescription<Func<double, double, string>>("Multiplication", "*", (a,b) => GetString(a*b)),
        new ProcedureDescription<Func<double, double, string>>("Division", "/", (a,b) => GetString(a/b)),
        new ProcedureDescription<Func<double, double, string>>("Power", "^", (a,b) => GetString(Math.Pow(a,b))),
    };

    var values = positiveValues.Union(negativeValues).ToList();

    foreach(var func in doubleDoubleFunctions)
    {
        var template = new FunctionTestsTemplate();
        template.Output.File = @"..\" + func.OpName + @"FunctionTests.generated.cs";
        template.ClassName = func.OpName + "FunctionTests";
        template.OperatorName = func.OpName;
        template.Operator = func.Op;    
        template.Values = values;
        template.Calculator = func.Calculator;
		template.EvaluateType = func.EvaluationType;
        template.Render();
    }
    
    foreach(var op in leftRightOperators)
    {
        var template = new OperatorTestsTemplate();
        template.Output.File = @"..\" + op.OpName + @"OperatorTests.generated.cs";
        template.ClassName = op.OpName + "OperatorTests";
        template.OperatorName = op.OpName;
        template.Operator = op.Op;    
        template.Values = values;
        template.NegativeValues = negativeValues;
        template.MalformedRightNegativeOnly = op.MalformedRightNegativeOnly;
        template.Calculator = op.Calculator;
        template.Render();
    }
    
    var t = new CaseTestsTemplate();
    t.Output.File = @"..\CaseTests.generated.cs";
    t.ClassName = "CaseTests";
    t.Render();
    
    var q = new PrecedenceTestsTemplate();
    q.Output.File = @"..\PrecedenceTestsBase.generated.cs";
    q.ClassName = "PrecedenceTestsBase";
    q.Render();
#>
<#+ 
public string GetString(double val)
{
	return double.NaN.Equals(val) ? "double.NaN" : val.ToString("R") + "d";
}

public string GetString(TimeSpan val)
{
	return "new TimeSpan(" + val.Ticks.ToString() + "L)";
}

public class ProcedureDescription<T>
{
    public ProcedureDescription(string opName, string op, T calculator, bool malformedRightNegativeOnly)
	{
        OpName = opName;
		Op = op;
    	Calculator = calculator;
		MalformedRightNegativeOnly = malformedRightNegativeOnly;
	}
	
    public ProcedureDescription(string opName, string op, T calculator, string evaluationType)
    {
        OpName = opName;
        Op = op;
        Calculator = calculator;
		EvaluationType = evaluationType;
    }
    
    public ProcedureDescription(string opName, string op, T calculator)
    {
        OpName = opName;
		Op = op;
    	Calculator = calculator;
    }
    
    public string OpName;
	public string Op;
	public T Calculator;
	public string EvaluationType = "Numeric";	
	public bool MalformedRightNegativeOnly = false;

}#>